<!------------------------------------------------------------------------------------------------->
<!--
  Copyright 2022 Sylvain Joube & Joel Falcou
  Licensed under the terms of the Attribution-ShareAlike 4.0 International License (CC BY-SA 4.0)
-->
<!------------------------------------------------------------------------------------------------->

<meta charset="utf-8" lang="en">
<!------------------------------------------------------------------------------------------------->

**Calcul performant et pratique avec C++20**
    <em><span class="current-date"></span>&nbsp;&nbsp;&nbsp;14e Journées Informatiques IN2P3/IRFU</em>
<small></small>
<br>
Sylvain JOUBE
<br>
<small>
Joël FALCOU, Hadrien GRASLAND, David CHAMONT.
</small>
<br>
<center><small>![](images/lisn.png style="height: 3rem")&nbsp;&nbsp;&nbsp;![](images/ijclab.png style="height: 3rem")</small></center>
<center>![](images/ccby40.png style="height: 0.7rem")</center>
<small><small>Powered by Markdeep and Markdeep-Slides</small></small>

---

## Idée de plan

  - 2 slides d'intro
  - 4 slides sur les templates & concepts
  - 4 slides sur constexpr etc
  - 2 slide avec exemples / conclusions
  - (ou alors 3, 3, 4 à voir)

---

## Problématique HPC et calcul en physique des hautes énergies (Intro 1/3)

### Ergonomie et performances difficiles à concilier
  * Nécessite des algorithmes performants
  * Exécution sur architectures parallèles modernes
  * Temps de développement colossal pour des non experts
  * => code souvent complexe ou mauvaises performances

### Devrait être accessible aux non experts
  * Code de haut niveau compréhensible écrit par et pour des scientifiques
  * Abstraction de la complexité matérielle et algorithmique sous-jacente
  * => Structures de données et algorithmes de haut niveau, faciles à manier mais performants

---

## Intro 1/3

### Problèmes de performances et d'ergonomie en C++
- Habituellement on se base sur l'utilisation de templates pour être à la fois efficace et avoir un code agréable à manipuler.
- Mais c'est compliqué de faire des choses compliquées avec les "templates à l'ancienne" (avant C++20).
- Les messages d'erreur sont très longs et peu explicites.

---

## Intro 2/3

### En C++20, le commité de standardisation a proposé des solutions
  - Simplification du code des templates avec constexpr etc. (calculs à la compilation)
  - Templates contraints par les concepts
  - Exemples pour montrer ce à quoi ça ressemble, comment ça s'utilise et les problèmes que ça résout + (à la fin ?) donner le use-case avec la bibliothèque Kiwaku

---

## Concepts - Plan pour les concepts (redondant)

- 1 slide d'explication de ce que c'est
- 1 exemple avec les concepts du standard : std::same_as, std::default_constructible etc.
- 1 exemple simple (est-ce que je suis un type arithmétique, ie pouvoir faire a+b et a*b etc)
- 1 exemple avec de la combination de concepts (arithmétique et streamable par ex)
- 1 gros exemple (de Joël) avec un concept qui correspond à la totalité des types algébriques
- Slide où on dit qu'on peut aussi surcharger des fonction avec (ou surcharger des structures)
- (2x3 bullets points pour expliquer la problématique et la solution)

---

## Concepts - Explication des concepts

---

## Concepts - Exemple avec les concepts du standard
- std::same_as
- std::default_constructible
- etc.

---

## Concepts - Exemple simple
- Concept de type arithmétique (i.e. pouvoir faire a+b et a*b)

---

## Concepts - Exemple avec de la combination de concepts
- Combinaison de concept arithmétique et streamable par exemple

---

## Concepts - Gros exemple (de Joël)
- Avec un concept qui correspond à la totalité des types algébriques

---

## Concepts - Surcharge de fonction

- Slide où on dit qu'on peut aussi surcharger des fonction avec (ou surcharger des structures)

---

## Constexpr - Plan pour constexpr (redondant)

- Notion de calcul à la compilation : avant c'était nul mais maintenant on a constexpr qu'on met où on veut
- fonctions constexpr
- valeurs constexpr
- if constexpr
- exemple
- paramètres template non typés (ex avoir des structures en paramètre template et non juste des entiers ou des types) (shape, extent[]() ce sont des nttp, non template type parameters)

---

## Constexpr - Notion de calcul à la compilation
- Avant c'était nul mais maintenant on a constexpr qu'on met où on veut

---

## Constexpr - Fonctions constexpr

---

## Constexpr - Valeurs constexpr

---

## Constexpr - if constexpr

---

## Constexpr - exemple

---

## Constexpr - Paramètres template non typés
- ex avoir des structures en paramètre template et non juste des entiers ou des types
- shape, extent[]() sont des nttp, non template type parameters

---

## Exemples / Conclusions
- 1, 2, 3 ou 4 slides ici.

---


## Exemples avec Kiwaku

- Et 2-3 exemples réalises avec Kiwaku.

- On va prendre un exemple qui ressemble au code moche de Detray mais pas une copie directe pour ne risquer de froisser personne. ("c'est pas ça être générique") Les concepts permettent une généricité claire et propre.

- Montrer ce à quoi ressemblent nos interfaces, propres et avec peu de templates.

- On peut écrire un exemple avec beaucoup trop de templates (12m10). Et montrer qu'avec des constexpr et des concepts c'est beaucoup plus lisible et agréable à développer.

---

ANCIENS SLIDES

---

## Idées plan

* 1 slide d'intro qui résume en bullet points ce bloc de texte :
> Dans le contexte du calcul haute performance et d'autant plus dans le cas du calcul scientifique et de la physique des hautes énergies, l'ergonomie et la performance du code de calcul sont deux aspects souvent antagonistes

> Le code se doit d’être performant au niveau algorithmique et au niveau de son adéquation avec les architectures parallèles modernes. Au niveau ergonomie, il est vital que le code écrit par et pour des scientifiques soit compréhensibles par ces derniers. Afin de bénéficier du meilleur de ces deux aspects, il convient d'utiliser des structures de données de haut niveau et des algorithmes permettant de simplifier le code tout en conservant un haut niveau de performance.

---

## Les templates
  * Rappel général sur la notion de template
  * Choses à ne pas faire avec des templates #ACTS / #DeathRay
  * Utilisation des templates sans concepts : ça tombe en marche mais bonjour les messages d'erreur de 3km de long : exemple ?

  ---

## Quoi ne pas faire : #DeathRay

https://github.com/acts-project/detray/blob/main/core/include/detray/grids/grid2.hpp
![](images/templatezzz.png style="width: 80%")

---

![](images/jagged_vector.png style="width: 60%")

---

## La magie des concepts
  * Définition : permettent de poser des contraintes sur les types et valeurs passés en paramètre d'un template + la page Wikipédia a l'air d'être bien faite, s'en inspirer ?
  * Reprendre l'exemple précédent et y ajouter des concepts pour montrer 1) que le code est plus lisible et 2) que les messages d'erreur sont à taille humaine

---

## Constexpr
  * évaluation à la compilation, qui a pas mal évolué avec constexpr et consteval
  * faire un maximum de choses à la compilation
  * optimiser le code quand on a des infos statiques

---

## Programmation générative ??
  * Est-ce qu'on parle un peu de la théorie de la programmation générative avec le super schéma ? Peut-être à la fin pour introduire Kiwaku ?

---



## Context

### nD Arrays : a pervasive tool
  * Main data structure in **numerical simulations**
  * Expected to be **efficient**
  * Expected to be **easy to use** yet  **expressive**

### Problem already addressed many times :

  ![](images/standards.png style="width: 40%")

---

## Context

### nD Arrays : a pervasive tool
  * Main data structure in **numerical simulations**
  * Expected to be **efficient**
  * Expected to be **easy to use** yet  **expressive**

### Problem already addressed many times :

  |  Libraries                                    | C++ Standard ?                      |
  |:----------------------------------------------|:-----------------------------------:|
  | `std::vector`, `std::valarray`, `std::mdspan` | <div style="color:#0f0;">✓</div>  |
  | EIGEN, Armadillo, xtensor, Blaze, Kokkos, ...      | <div style="color:#F00;">✗</div>  |

<center>
!!! ERROR:
    **What if the real issue was a software design problem?**
</center>

---

## nD Array Design Space

### A small sampling
  * Owning or non-owning array ?
  * Are my dimensions runtime or compile-time ? or both ?
  * Storage order : C, FORTRAN, arbitrary, ... ?
  * Indexes start at 0 ? 1 ? -3 ? any user value ?
  * Memory allocation : Allocator-based ? Which allocator model ? Stack or Heap ?

### One implementation to rule them all ?
  * Monolithic implementation leads to unmaintainable code
  * Arbitrary restrictions on API is not a solution

!!! Tip: Our Position
    Apply a different design strategy to the problem

---

## Generative Programming [Czarnecki et al. : 2002]

********************************************************************************
*
*   +---------------+   +-------------------------+   +---------------+
*  | Domain Specific | |   Generative Components   | | Executable Code |
*  |   Description   | +                           + |                 |
*  |                 | |                           | |       +-+       |
*  |       o         | |      .--------------.     | |  *-->|  +-->o   |
*  |      / \   -----+-+---->|   Translator   +----+-+->     +-+       |
*  |     *   *       | |      '--------------'     | |        ^        |
*  |     |  / \      | |             ^             | |        | In     |
*  |     v o   *     | |             |             | |  .--.--+--.--.  |
*  |     o           | |             v             | |  | a| 7| b| x|  |
*  |                 | |   .-------------------.   | |  '--'--'--'--'  |
*   +---------------+  |  |      Parametric     |  |  +---------------+
*                      |  |    Sub-Components   |  |
*                      |  |                     |  |
*                      |  |  +-+  .----.   +    |  |
*                      |  | |   | |    |  / \   |  |
*                      |  |  +-+  '----' +---+  |  |
*                      |  | *    o  ------->    |  |
*                      |  |    +---+  .----.    |  |
*                      |  |     \ /  |      |   |  |
*                      |  |      +    '----'    |  |
*                      |   '-------------------'   |
*                       +-------------------------+
*
********************************************************************************

---

## Generative Programming for nD arrays

### Advantages of Generative programming
  * Domain specific descriptor and components are easy to extend
  * Reduce the number of implementations from $|X|\cdot|Y|$ to $|X| + |Y|$
  * Generative programming in C++ is based on **template metaprogramming** and **code generation**

<!--
  Le rôle des templates : Modular implementation => only compile what is really needed

  Notre position c'est que qu'on peut utiliser la generative programming (GP) pour résoudre ce problème de design d'une manière suffisamment flexible à l'usage pour résoudre ce problème et répondre à tous les use-case. Kiwaku est censé résoudre ce problème, exemple de code qui claque. -->

<script type="preformatted">
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ c++
// Wow, such C++ code
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
</script>

---

# Existing solutions

---

## Overview

### What do users want?
  * Small and non-ambiguous interface
  * Clear and concise documentation
  * High discoverability

### What do users deal with?
  * Some APIs suffer from feature creep
  * Some APIs require strong programming skills
  * Some (most) APIs are sometimes counterintuitive and verbose

### What is missing?
  * User friendly for non computer experts
  * Keep API scope reasonable

---

## Painful example : std::vector

### Higher dimensions vector declaration

<script type="preformatted">
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ c++
// 5D vector declaration and creation
std::vector<std::vector<std::vector<std::vector<std::vector<float>>>>>
  my_vect(  d0,
            std::vector<std::vector<std::vector<std::vector<float>>>>(d1,
            std::vector<std::vector<std::vector<float>>>(d2,
            std::vector<std::vector<float>>(d3,
            std::vector<float>(d4)
            )))
          );

// Access to fields
my_vect[i0][i1][i2][i3][i4] = some_float;

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
</script>

  * For a $d_1 \times d_2 \times \ldots \times d_{n}$ array, $1 + d_1 \times d_2 \times \ldots \times d_{n-1}$ allocations occurs
  * Data access induces spurious cache misses
  * Memory is not contiguous, leading to sub-par performance

---

<!-- ## Painful example : std::pmr

### Constructing, assigning, and destroying container objects means :

  * An **atomic** load on default constructor from std::pmr::get_default_resource()
  * A **virtual call** for every move-assignment
  * Verbose, complex, hard to read code

<script type="preformatted">
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ c++
// define allocation behavior via a custom "memory_resource"
class my_memory_resource : public std::pmr::memory_resource { ... };
my_memory_resource mem_res;
auto my_vector = std::pmr::vector<int>(0, &mem_res);
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
</script>

TODO : Il y avait quelque chose à dire ici mais je sais plus quoi

L'utilisation de memory-ressource est malvenue

--- -->

## Painful example : std::mdspan

### Extent definition

<script type="preformatted">
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++ linenumbers
std::extents<4,3> fixed_4x3;                                        // Compile-time known extent
std::extents<std::dynamic_extent,std::dynamic_extent> dynamic(4,3); // Runtime known extent

std::extents< std::dynamic_extent,std::dynamic_extent,std::dynamic_extent,std::dynamic_extent
            , std::dynamic_extent,std::dynamic_extent,std::dynamic_extent,std::dynamic_extent // Ughhhh
            > dyn8d;
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
</script>

### Type interface

<script type="preformatted">
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++ linenumbers
template< typename T, typename Extents
        , typename LayoutPolicy = std::layout_right, typename Accessor = std::accessor_basic
        >
class mdspan;
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
</script>

---

## Painful example : Expression template libraries

### API inconsistencies and traps

<script type="preformatted">
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++
auto unexpected_lazy_evaluation(matrix A, B)
{
  auto C = A * B; // The type of C is not matrix
  return C;
}

template<typename T> auto dangerous_reference_to_temporary(T const& t)
{
  matrix m = t + t;
  return m / t; // returns a reference to a temporary
}

template<typename T> auto silent_performance_bug(T const& t)
{
  T that = t * t; // may or may not be of type T
  return that;
}
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
</script>

>>> Conclusion orale et on passe à la suite. Dire à l'oral "E.g EIGEN"
>>> EIGEN ça pue

---

# Kiwaku

---

## Kiwaku design - Overview

### Scope reduction
  * monolithic "all in one" solutions are bound to fail
  * Kiwaku only works with numerical nD arrays

TODO : what's more ?

Plutôt dans "Kiwaku design" nan ? Réduction du scope : on n'essaie pas de trouver une solution à tous les problèmes, on ne s'occupe que des tableaux numériques blablabla tu sais de quoi je parle ;)

---

## Kiwaku design

### `kwk::view`
  * Never owns any memory
  * Wraps existing memory in a nD-array like interface
  * Is designed to be as small as possible in 'resting position'

### `kwk::table`
  * Owns memory allocated via an allocator or on the stack
  * Wraps said memory in a nD-array like interface
  * Is designed to be as small as possible in 'resting position'

  ### Two sides of the same coin
  * A `kwk::table` is a `kwk::view` over the memory it owns
  * Efficient `kwk::view` leads to efficient `kwk::table`


---

## Kiwaku design

### Supported options

  * Kiwaku options are defined as orthogonal policies
  * can be used as positional arguments in constructors
  * options are exploited both at compile-time and run-time

|  Options          | Values                                            |
|:------------------|:--------------------------------------------------|
| `kwk::source`     | pointers, static arrays, contiguous ranges        |
| `kwk::size`       | `kwk::of_size(dn...)`, integers are 1D-shapes     |
| `kwk::base_index` | `kwk::index<I>`, `kwk::indexes<I0,I1,...>`        |
| `kwk::label`      | any string-like values                            |
| `kwk::allocator`  | any types modeling `kwk::concepts::allocator`     |



---

## Simple view construction

<iframe width="100%" height="75%" src="http://localhost:10240/e#g:!((g:!((g:!((h:codeEditor,i:(filename:'1',fontScale:18,fontUsePx:'0',j:1,lang:c%2B%2B,selection:(endColumn:1,endLineNumber:1,positionColumn:1,positionLineNumber:1,selectionStartColumn:1,selectionStartLineNumber:1,startColumn:1,startLineNumber:1),source:'//+simple_view.cpp%0A%23include+%3Ckwk/kwk.hpp%3E%0A%23include+%3Ciostream%3E%0A%0Aint+main()%0A%7B%0A++using+namespace+kwk%3B%0A%0A++double+data%5B6%5D+%3D+%7B1.2,2.3,3.4,4.5,5.6,6.7%7D%3B%0A%0A++auto+vd+%3D+view%7B+source+%3D+data+%7D%3B%0A++std::cout+%3C%3C+vd.shape()+%3C%3C+%22%5Cn%22%3B%0A++std::cout+%3C%3C+vd.rank()+%3C%3C+%22%5Cn%22%3B%0A++%0A++for(std::size_t+i+%3D+0%3B+i+%3C+vd.size()%3B%2B%2Bi)%0A++++vd(i)+*%3D+10.%3B%0A%0A++for(auto+e+:+data)%0A++++std::cout+%3C%3C+e+%3C%3C+%22+%22%3B%0A%7D+'),l:'5',n:'0',o:'C%2B%2B+source+%231',t:'0')),k:50,l:'4',n:'0',o:'',s:0,t:'0'),(g:!((g:!((h:compiler,i:(compiler:g10,filters:(b:'0',binary:'1',commentOnly:'0',demangle:'0',directives:'0',execute:'0',intel:'0',libraryCode:'0',trim:'1'),flagsViewOpen:'1',fontScale:18,fontUsePx:'0',j:1,lang:c%2B%2B,libs:!((name:kiwaku,ver:trunk)),options:'-O3+-DNDEBUG+-std%3Dc%2B%2B20',selection:(endColumn:1,endLineNumber:1,positionColumn:1,positionLineNumber:1,selectionStartColumn:1,selectionStartLineNumber:1,startColumn:1,startLineNumber:1),source:1,tree:'1'),l:'5',n:'0',o:'Intel+-+G%2B%2B+10+(C%2B%2B,+Editor+%231,+Compiler+%231)',t:'0')),k:50,l:'4',m:50,n:'0',o:'',s:0,t:'0'),(g:!((h:output,i:(compiler:1,editor:1,fontScale:18,fontUsePx:'0',tree:'1',wrap:'1'),l:'5',n:'0',o:'Output+of+Intel+-+G%2B%2B+10+(Compiler+%231)',t:'0')),header:(),l:'4',m:50,n:'0',o:'',s:0,t:'0')),k:50,l:'3',n:'0',o:'',t:'0')),l:'2',n:'0',o:'',t:'0')),version:4"></iframe>

---

## Rank 3 view from standard range

<iframe width="100%" height="75%" src="http://localhost:10240/e#z:OYLghAFBqd5QCxAYwPYBMCmBRdBLAF1QCcAaPECAMzwBtMA7AQwFtMQByARg9KtQYEAysib0QXABx8BBAKoBnTAAUAHpwAMvAFYTStJg1DIApACYAQuYukl9ZATwDKjdAGFUtAK4sGe1wAyeAyYAHI%2BAEaYxHoADqgKhE4MHt6%2BcQlJAkEh4SxRMVy2mPaOAkIETMQEqT5%2BRXaYDskVVQQ5YZHRegqV1bXpDX3twZ353VwAlLaoXsTI7BzmAMzByN5YANQmy24A1gDuewD0h3sAdAixsTvYJhoAgitrG5jbuwBuTUTEt/dPZlWDHWXi2OzcTl6xEwrD%2Bj3%2BwQImxYTGCEEm/xMAHYrI9NpsvIkjJtmGwFLEmAtNmcdrinnjNr10CAQF8HCRwehZhF6LdNugmJUIFIMcs6f98UwvERNh90O8ACKyvCYA7YiyM2bzN47JUCyrbBn440m02kTaoKgAfUSAC9MBAzKRls6MUbTR78eaDFFaIrtmYzBEmEorVRoQBHcxmCWeuPYhW02OxpkstDS95ucGy9DnBQIJixB2TTPZ6MmACsbgY5bFKYIzJQsyR4Oz%2BBY4I0twgcpLrd2AbMm1Ug8NDzjJv7bn5eA7uy43d7pYH0eHo9jE%2BX0/b4Jjy2wPfQfd2ZcDlertbp%2BNTTYzU5z52Ihj26K3g/PNbPdfhDP4xAgN52pgVpIngQ66psXZipsYGZjOc5uHuB69kmljWGBbrjsaf4AQ2LJASBMFcP6UEangxFtrO4ILvuh6ilYaGWORmEmjhgF4PahF4BoJG0jBPGUQhUHIUeqEMRY3ElmOHpyhA3HkEUGH%2BnJXaWFMAYalwGgAFRyQual9pYmxaTpckxgZSY/lhOFSjKbwgPygpMCxxo3umLYngOOqedOq6XpODJuc2b7llWNZhZeyaBXht4eVmA5yiFZ4RV%2BGqYliCocNMtCcBWvB%2BBwWikKgnBZoxGoKFqVIrDwpAEJoWXTHsIAVho%2BicAALPlDXFZwvAKCAbX1YVWWkHAsAwIgTYsLEdDROQlBoDNc0xMAWl8HQBDRANEARD1ETBFUACenC1UtbCCAA8gwtAnSNpBYCiRjiPd%2BDQs0XwDfdmCqE00qLEViIlD1tB4BET7EEdHhYD1BDELOp2jVQBjAAoABqKoHJdRYFbV/CCCIYjsFIMiCIoKjqPduhFAYRgoNY1j6GDA2wKS7B7HgBxMHsXikF8MRw14DB7JM0yoLEZQMF9AC0l3LJs0sKqECrYBYcgAOIK0yuqmOVZhFY0zTOBArgDPUpCBKMeQFBkiSS2bttZAwHTWxMxSlC0wwOw0JTfJ7bQu10hS2F7nh1D0wyB%2BMhTTJVcwLHocOYIsPDZbl3X3SVHAAJKCCUCubOrDNGVpmwQGV4nmrghAkAGyxFJsHjLfQxB11MvDDVooukM1rXtRwXWkCwIDLB15xmB1ACcHVYlwHUVpIWJYssWLSAVRVZ/1g11Q10zjVNzaxNKC0QEts0t/4%2BA/Ho%2BPCKI4gk7f5NqLD0Ip7wBxPrEiNpxweWkOvXgWdLrSiPkiS0mxc5bT9NLQuxdNI8XLqgZu0Q26TA7rvaYCAYRYBiOifug9h4ADYKznCxK1CsZhJAVg6lwQMRDAwAJ6pvWw29O6NR7i1NqOUODLAzhvPqO8Rrdx4WYfhQDBHsO7vzRIzgOpAA%3D"></iframe>

---

## Code generation comparison with standard C

<iframe width="100%" height="75%" src="http://localhost:10240/e#z:OYLghAFBqd5TKALEBjA9gEwKYFFMCWALugE4A0BIEAZgQDbYB2AhgLbYgDkAjF%2BTXRMiAZVQtGIHgA4BQogFUAztgAKAD24AGfgCsp5eiyahUAUgBMAIUtXyKxqiIEh1ZpgDC6egFc2TA3cAGQImbAA5PwAjbFIDAAd0JWIXJi9ffwSklKEQsMi2GLiee2xHZyERIhZSInS/AJKHbCdUqpqiPIjo2IMlatr6zKaBztDuwt6eAEp7dB9SVE4uSwBmUNRfHABqM1WPAGsAdwOAemODgDokePi93DMtAEFHp6JsNnijd72PIgBPeLMdjYbYAFXI2xYPhIlzh2wA8kp7q8AG7oAiYbbACDbC4gECogjYI6/CFIuGXe7bVHTV5mADsNme222glIEH6mAJ8SIpEINBoAH0iNsCHsACJaPZWcX7VGXZIAL2wEDpqxs1lsBDpLNZNIgOu2ACpJdsLJdVgBWAAsNBl9IZEvpz3RmLZQoutHo6BYRGN215FDFwm2TF1LyZr1ZOLxJwJRJJjKs%2BJASnmi1BZqDkNTyqzqwlYcZEvVzMjEq4s3o3Ct/ACXB05HQ3A8tls23TCyWuwsqz45CI2ir5AgKAwnwYsUo1An8SncWAPC0AgY71ISmoUWH5CioRq/24A4nHGECKY9EPjf4ODYxmAkmv5EIpBazlR2E3T%2Bw6haMOWA6hO8NZPvQBBRKQB5eDgO58gQbBHiONBGMASgAGrEkcCJAg2A6CMIYgSJwMhyMIyhqJoT76CURgmGg7bWIY4GbrArAcCABwEEcLAHD45AfnEfI%2BEwBzTLM6C8qkX4ALQIqs2zSRK4QSrgVgKAA4gpXKSuYWrWBYTbNK0rgQO4QyNOQwTjAURRZMkFRpN4DR2TkTBdDZUylOUbSjOZfRlG%2BPkdO5PTFPYvlOcM4XBdZoVSLMXaZgYfLYABI4gXW5ANk2LZcAAksIZQKds6kMVY2zLtsEBtnpdjbPgxBkL2/aQl4k6MKQzUzPwQ7XmJ5AHCANoWqsACcw08Fa/bSAAbKNqxaKNhjcDa/AIVaK7ZfwuX8JuK69TosxwLA45YHghAkBQVC0FObFpaRojiJIJH4YoKgaDu%2BgWIY970bVXmBSZZmRRZVn5HFJSJPZqR%2BZD2QOSFkxhUZDntIMIP%2Bd5lSjIjtkjB0sPRbUuNTAlGZLNwawbFsBYeKgXI4PaqwPM8aIYliwqoN6vr%2BoGfKQkBYYRsm0ZsmQnJENyIBBgKwqinKUoynKHhMA6tU6qLrJBmYVqyjrRamoW5qWraTPliW6W1vWO65TVmrlYlPZrBYPXDkdp3tdO11zguIBLiudD0Oum4QNuT57qwpBXse6BsKeRDnpeO63vej5Ni%2BgUfl%2BTY/n%2B7yIZQhUgU2YEQVBZ2waQ8GIbMyEsKhGEkthzAF69hHPbIr3kR9VEgN9tGmGVTFRCxarNpJQgyXJClKSpamadJ2mFrp9sGbtAXGQEplMJ4GMlGDEx4%2BQUOuYTJ8I7FSOY4DTBo3Ue8A5vd8k8jEUZBZ/QxeDV8zHM3acN9FKaVqxWyyjbbgBVgLFVKrVCqWgqp21sJCBql1mrfW2G1ecHU0HTFdn1WYSBsAsBwHEMeIFVrkHWptcBXBdogH2m7WYg0xqXBtAyaQo0rQMlGpNaQ/YZpWmWlwVY1snw7UHG7UciAxwgFljOWg8h27EU7vIbulES5IE3DRTRssARAnoeQUgmi%2B6GJ0QQQUejOBaBAVwTKW1mzcAlOYmg2xG5HFiNsSBRVpIlTKnAmkShPFF2gX45ceDDoEKISQ6gTCQAzS0JcK0FhlzDS0NIG0PAZp8MmkIih9jxF7QkfgoRLswFiO4OEqsswBLJFcDaIAA"></iframe>

---

# Conclusion



---

## Conclusion

### Current work
  * [Kiwaku on Github](https://github.com/jfalcou/kiwaku/)
  * Allocators : adaptation of Alexandrescu's model
  * Slicers : complete the implementation

### Future of my PhD
  * Support for tiling and non-trivial walkthrough (Morton, ...)
  * Support for data locality in distributed computing scenarios
  * Support for heterogenous platforms (GPU, FPGA, ...)
  * Seamless integration with SYCL


<!--TODO : faire cette slide

Qu'est-ce qu'on est en train de faire maintenant
- Allocateurs
- Slicers
- Où est-ce qu'on veut aller dans la thèse :
  - Gestion de l'hétérogénéité (localité des données par exemple ?)
  - Distribution, compatibilité GPU, interopérabilité avec des outils actuels comme SYCL. Par exemple, écrire du Kiwaku qui génère du code SYCL.
-->

<!------------------------------------------------------------------------------------------------->

---

# Thanks for your attention !

<!------------------------------------------------------------------------------------------------->
<!-- Markdeep slides stuff -->
<script>
    markdeepSlidesOptions = {
        aspectRatio: 16 / 9,
        theme: 'lri',
        fontSize: 22,
        diagramZoom: 1.0,
        totalSlideNumber: true,
        progressBar: true,
        breakOnHeadings: false,
        slideChangeHook: (oldSlide, newSlide) => {},
        modeChangeHook: (newMode) => {}
    };
</script>
<link rel="stylesheet" href="../markdeep-slides/lib/markdeep-relative-sizes/1.09/relativize.css">
<link rel="stylesheet" href="../markdeep-slides/markdeep-slides.css">
<script src="../markdeep-slides/markdeep-slides.js"></script>

<!-- Markdeep stuff -->
<script>
    markdeepOptions = {
        tocStyle: 'none',
        detectMath: false,
        onLoad: function() {
            initSlides();
        }
    };
</script>
<style class="fallback">body{visibility:hidden;white-space:pre;font-family:monospace}</style>
<script src="../markdeep-slides/lib/markdeep/1.09/markdeep.min.js" charset="utf-8"></script>
<script>window.alreadyProcessedMarkdeep||(document.body.style.visibility="visible")</script>
